import {Event, Events} from 'event'
import {EventHook} from 'parser/core/Dispatcher'
import {dependency} from 'parser/core/Injectable'
import {Data} from 'parser/core/modules/Data'
import {Invulnerability as CoreInvulnerability} from 'parser/core/modules/Invulnerability'
import {Actor} from 'report'
import {filter, noneOf, oneOf} from '../../../core/filter'

const DOOMTRAIN_ACTOR_KIND = '18999'
const AETHER_ACTOR_KIND = '19002'

/* eslint-disable @typescript-eslint/no-magic-numbers */
const DERAIL_ACTION_IDS: number[] = [
	45709, // the first one after intermission
	46489, // the second one
	46490, // the last one
]
/* eslint-enable @typescript-eslint/no-magic-numbers */
const RUNAWAY_TRAIN_ACTION_ID = 45645

export class Invulnerability extends CoreInvulnerability {
	@dependency private data!: Data

	private doomtrainActor: Actor | undefined
	private aetherActorIds: Array<Actor['id']> = []

	private derailEndByActionHook: EventHook<Events['action']> | null = null
	private derailEndByPrepareHook: EventHook<Events['prepare']> | null = null

	override initialise(): void {
		super.initialise()

		this.doomtrainActor = this.parser.pull.actors.find(actor => actor.kind === DOOMTRAIN_ACTOR_KIND)
		this.aetherActorIds = this.parser.pull.actors.filter(actor => actor.kind === AETHER_ACTOR_KIND).map(actor => actor.id)

		this.addEventHook(
			filter<Event>()
				.type('damage')
				.cause(this.data.matchCauseActionId([RUNAWAY_TRAIN_ACTION_ID])),
			this.onRunawayTrain
		)

		// Shouldn't happen but I can't be arsed to figure out the null coalesce
		if (this.doomtrainActor == null) { return }

		this.addEventHook(
			filter<Event>()
				.type('action')
				.source(oneOf([this.doomtrainActor.id]))
				.action(oneOf(DERAIL_ACTION_IDS)),
			this.startDerailUntargetable
		)
	}

	// The death event for the aether add in the intermission phase can apparently sometimes ghost, how fun
	// If we see the runaway train damage event from the intermission end, and haven't seen it die,
	// just go ahead and "kill" the add...
	private onRunawayTrain(event: Events['damage']) {
		this.aetherActorIds.forEach(aetherActorId => {
			// If we got an actual death event, we don't have to fake one
			if (!this.isActive({
				timestamp: event.timestamp,
				actorFilter: filter<Actor>().id(aetherActorId),
			})) {
				this.addStartEdge(aetherActorId, event.timestamp)
			}
		})
	}

	// When Derail hits, Doomtrain is no longer targetable, but DoTs are still ticking
	private startDerailUntargetable(event: Events['action']) {
		if (this.doomtrainActor == null) { return }
		this.addTypeStartEdge('untargetable', this.doomtrainActor.id, event.timestamp)
		this.setDerailEndEdgeHooks()
	}

	// We need to simulate the "first time targeted" behavior after each derail edge start
	// We'll hook action and prepare events targeting Doomtrain, as long as they're not sourced from Doomtrain itself
	private setDerailEndEdgeHooks() {
		if (this.doomtrainActor == null) { return }
		const doomtrainTargetFilter = filter<Event>().target(this.doomtrainActor.id).source(noneOf([this.doomtrainActor.id]))
		this.derailEndByActionHook = this.addEventHook(
			doomtrainTargetFilter.type('action'),
			this.endDerailUntargetable
		)
		this.derailEndByPrepareHook = this.addEventHook(
			doomtrainTargetFilter.type('prepare'),
			this.endDerailUntargetable
		)
	}

	// When we see an event targeting Doomtrain, we can close the untargetable window
	private endDerailUntargetable(event: Events['action'] | Events['prepare']) {
		this.unsetDerailEndEdgeHooks()
		if (this.doomtrainActor == null) { return }
		this.addTypeEndEdge('untargetable', this.doomtrainActor.id, event.timestamp)
	}

	// Unset the hooks when we're done to save processing time until the next window begins
	private unsetDerailEndEdgeHooks() {
		if (this.derailEndByActionHook) {
			this.removeEventHook(this.derailEndByActionHook)
			this.derailEndByActionHook = null
		}
		if (this.derailEndByPrepareHook) {
			this.removeEventHook(this.derailEndByPrepareHook)
			this.derailEndByPrepareHook = null
		}
	}
}
